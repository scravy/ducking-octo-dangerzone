=   Example: A Swing Calculator written in Haskell
label sec:examples

.haskell
    import Foreign.Java
    import Control.Monad
    import Data.IORef
    import Java.Awt.Event
    import Javax.Swing
    import Javax.Swing.JButton (new'JButton', addActionListener)
    import Javax.Swing.GridLayout (new'GridLayout'')
    import Javax.Swing.JFrame (new'JFrame, add, setLayout, setTitle)

    main = runJavaGui $ do

        currentValue <- newIORef ( 0 ::  Double )
        stack        <- newIORef ([] :: [Double])

        (Just jFrame) <- new'JFrame

        new'GridLayout'' 4 4 >>= setLayout jFrame

        let buttonText = [ "1", "2", "3", "*"
                         , "4", "5", "6", "-"
                         , "7", "8", "9", "+"
                      , "Push", "0", "",  "/" ]

        buttons <- mapM new'JButton' buttonText :: Java [Maybe JButton]

        let updateDisplay = do
                val <- io $ readIORef currentValue
                setTitle jFrame (show val) :: Java ()

            exec = \operation -> do
                xs <- io $ readIORef stack
                case xs of
                    [] -> setTitle jFrame "Empty Stack!"
                    (x:xs) -> do io $ do updateIORef' stack tail
                                         updateIORef' currentValue (flip operation)
                                 updateDisplay
                                            
            handleAction :: String -> ActionEvent' -> Java ()
            handleAction = \whatFor actionEvent -> do
                case whatFor of
                    "" -> return ()
                    "Push" -> io $ do
                        v <- readIORef currentValue
                        modifyIORef' stack (v:)                        
                    "*" -> exec (*)
                    "-" -> exec (-)
                    "+" -> exec (+)
                    "/" -> exec (/)
                    digit -> do
                        io $ modifyIORef currentValue (\x -> x * 10 + read digit)
                        updateDisplay                            

        forM (zip buttons buttonText) $ \((Just btn), text) -> do
            () <- jFrame `add` btn
            () <- btn `addActionListener` (handleAction text)

        () <- setSize jFrame 400 300
        () <- jFrame `setLocation` Nothing
        () <- jFrame `setVisible` True
        return ()
.

    This is a very simple editor that is written in Haskell
    using the bindings generated by \#j2hs# for Java SE 7.

:=  A short walk-through:
    Lines 1 - 8 contain \#import# statements. These tend to become quite large
    when using functions from many modules. To avoid ambiguity we only
    import the functions that are really needed.

    In line 10 the JVM is started and (only relevant for OS X) any
    special precautions for running a GUI are taken.

    In line 12 and 13 two mutable variables are being set up
    which hold a *current value* and a stack of values.

    In line 15 a new Window is creates (a \#JFrame#) which will
    be displayed in lie 59. We know that the creation of a JFrame
    can not fail, thus we are being brave and match it directly
    with \#(Just jFrame)# such that \#jFrame# contains now a
    value of type \#Javax.Swing.JFrame'#.

    In line 17 the set the layout for the frame (actually for the
    panel inside the frame, but this thesis is not a beginners Java course).

    In lines 19 - 24 twelve buttons are created. References to these buttons
    are being held in \#buttons# such that we can add *action listeners*
    later on.

    Line 26 - 28 define an @updateDisplay@ function which reads
    the currentValue and displays it as the title of the window
    (we are being modest here and do not add an extra text field
    for showing the results).

    Line 30 - 36 defines a functions which executes a given operation
    on the head of the stack and the current value. The type of this function
    is \break\#(Double -> Double -> Double) -> Java ()#. This function
    will also store the result in the current value and call \#updateDisplay#.

    Line 38 - 51 define an action handler, actually several action
    handlers. Based on the first argument the action handler decides
    what it will do with the given action event. Sections (partially
    applied functions) of this will later on act as the real
    \#ActionHandler# objects that we add to our buttons. The most
    complex operation here is entering a digit and updating the
    display.

    Line 53 - 55 adds the buttons to the \#jFrame# and adds
    the action listeners.

    The last three lines adjust the window to a size
    of 400 x 300 px and center it on the screen (passing \#null#,
    a.k.a. \#Nothing#, to \#setLocation# causes a Swing JFrame
    to be centered on the screen).

    Note the funny looking invocations of the functions
    returning void. Since we could equally well decide to
    get an \#Either JThrowable ()# we have to make it explicit
    that what we want is void. Hence the pattern matching
    with \#()#.
    
