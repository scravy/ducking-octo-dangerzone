=   Translating APIs between Haskell and Java
label sec:translation

right
    *There are two sides to every issue: \break
    one side is right and the other is wrong, \break
    but the middle is always evil.*
    \break -- //Ayn Rand//
    \break \space
reset

==  Translating Java idioms into Haskell

    The public API of a Java library consists of a set of *packages*.
    A package contains a set of classes where a class maybe an
    actual *public class*, an *interface*, an *enum* or an *annotation*.
    A Java class declares a public programming interface.    
    In order to avoid ambiguity we will call such an interface
    a *Java class interface*. We will refer to the set of Java classes
    in a Java package as *Java package interface*.

    Translating a Java class interface to Haskell requires finding a
    suitable representation of the Java idioms defined above in the
    Haskell language. We assert that the reader is familiar with
    the Java programming language and its constructs.


=== The Zoo of Things in Java vs. Functions in Haskell
label sec:names

    Java is a rather complex language contrasted to Haskell. While
    in Haskell there is only data and a special datatype of kind
    \#* -> *# (functions), Java has fields, functions, constructors,
    static initializers, behavioural declarations like \#strictfp#
    or \#synchronized#, etc. To be fair: There are a lot of different
    things in Haskell too, but on the surface level they are all types
    (having a certain kind) or values (having a certain type). This
    top level space is much more crowded in Java.

    When translating these top level constructs from Java to Haskell
    we have no choice but to turn anything into a function, which
    especially poses a problem regarding the names of things. While
    it is possible in Java for two members to have the same name
    they are not allowed to have the same name in the top level
    namespace of a Haskell module. Also field access will have to be
    realized by using a *getter* and a *setter* function. Even worse:
    Method names in Java are allowed to be overloaded.

    While overloading is generally possible in Haskell, it is not the
    most advisable thing to do. In many situations it will also
    require the use of certain non-standard Haskell extensions,
    most prominently *flexible instances*:

.
figure
.haskell
    class MethodPrint a where
        print :: a

    -- standard Haskell only allows types to be parameterized
    -- by a type variable in the instance head, but (->) is
    -- actually parameterized by `Int' and `IO ()' here.
    instance MethodPrint (Int -> IO ()) where
        print x = ...

    instance MethodPrint (Object -> Int -> IO String) where
        print o x = ...

caption A possible overloading scheme using flexible instances.
endfigure

    As a matter of fact, the generous
    use of overloading will defeat many other features of Haskell,
    like type inference and composability. Too much polymorphism
    may also lead to ambiguity in expressions and force the Haskell
    programmer to annotate many more type declarations than necessary:

figure
.haskell
    class A a where f :: a
    class B a where g :: a -> String

    h = g f -- What is the type of f?
.
caption Composability screwed up.
endfigure

    There is another issue with overloading: It is typically achieved
    by using type classes. But as we will see type classes are our
    weapon of choice for realizing subtype polymorphism in Haskell.
    Mixing both the ordinary overloading of methods with fields,
    constructors, and subtype annotations will definitely pollute any
    sensible translation with overly verbose type annotations. Adding
    an encoding for subtype polymorphism will most certainly lead to
    overlapping instances and eventually render a translation impossible
    or force an insane amount of type trickery.

    We therefore keep things separated. Fortunately the allowable characters
    for the definition of method names in Java and function names in
    Haskell are different, so that we can use some special characters
    to differentiate matters. Unfortunately the allowable characters
    for the definition of method names in Java and function names in Haskell
    are different, so that we need to translate them where incompatible.

:=  The actual naming scheme: that is chosen in this paper is the
    following:

::  Fields:
    For every public field a function with the name \#get'<field># is
    created, where \#<field># is the name of the field. Since static
    and non-static fields share a common namespace in Java we do not
    have to distinguish them in this regard. For non-final fields
    also a setter is also created: \#set'<field>#.

::  Methods:
    For every public method a function is created. Since no name in
    Java can contain the apostrophe they are guaranteed not to clash
    with getters and setters. Since functions in Haskell are only
    allowed to begin with a lower case letter, a function that would
    otherwise start with an upper case letter is prefixed with an
    underscore (\#_#).

::  Constructors:
    Every constructor is translated into a name of the form
    \#new'<type>#, where \#<type># is the name of the respective class.

::  Overloading:
    Since we do not intend to overload function names in Haskell,
    every overloaded name is split up into as many names as the
    name is overloaded. The names are distinguished by appending a
    distinct amount of apostrophes. This may lead to funny names like
    \#print''''''# for heavily overloaded methods.

::  Keywords:
    Whenever a translated name would be equal to a reserved word in
    the Haskell language, it is prefixed with an underscore (not that
    there are no upper case keywords in Haskell, so this will not produce
    any conflicts with upper case method names, which are also augmented
    with a leading underscore).
    
::  General remark:
    Java names are allowed to contain the dollar sign. However, the
    actual use of the dollar sign in any name is frowned upon and
    may in fact lead to problems even within the Java ecosystem,
    since the virtual machine uses the dollar sign to distinguish
    auto generated methods and classes from user generated ones. It
    is a *leaky abstraction*. Since there is no method or field name
    within the Java standard library which actually contains a dollar
    sign the matter is not very urgent. For completeness however we
    will replace any occurrence of the dollar sign with two apostrophes.
    Two apostrophes are chosen since a single apostrophe is already
    used for distinguishing the namespace of getters, setter, methods,
    and constructors. \break
    The alert reader may have noticed that there is a slight possibility
    of a name clash given by this naming scheme: A method \#print$# and
    the third overloaded method with the name \#print# could result in
    the same name. Because of this we will replace a trailing dollar sign
    not with two apostrophes, but with an apostrophe and an underscore.


=== The Java Monad
label sec:javaMonad

    Every action in the Java programming language is executed within
    the *Java virtual machine* (JVM). Every action may have a side
    effect that alters the state of the virtual machine. Thus executing
    a Java action will require the presence of a virtual machine.

    A suitable representation for this is to create a custom monad,
    the Java monad. In the Java monad a reference to a virtual machine
    is available, it is therefore a State monad (where the state is the
    state of the virtual machine or a reference to the virtual machine).
    Since interacting with a virtual machine is an IO action and the
    virtual machine itself can perform IO actions all the time it also
    needs to be used within the Haskell IO monad.

    We will therefore define the Java monad as a \@StateT@ monad
    transformer that wraps the IO monad and has a custom state,
    a \@JVMState@:

.haskell
    newtype Java a = Java (StateT JVMState IO a)
        deriving (Monad, MonadState JVMState, Functor, MonadIO)
.
    A function \#runJava :: Java a -> IO a# can be used to run a
    computation in the Java virtual machine inside the IO monad.

=== Primitive Types
label sec:primitiveTypes

    In principle every primitive can be mapped one to one to
    a type of the Haskell 2010 base modules \#Data.Int#, \#Data.Word#,
    \#Double#, \#Float#, or \#Bool#.

>@  ll|ll
>   byte
>   Data.Int.Int8
>   boolean
>   Prelude.Bool
>-
>   short
>   Data.Int.Int16
>   char
>   Data.Word.Word16
>-
>   int
>   Data.Int.Int32
>   float
>   Prelude.Float
>-
>   long
>   Data.Int.Int64
>   double
>   Prelude.Double

    While this would be an adequate solution it does not completely
    capture how Java deals with primitive types. In particular Java
    has a limited notion of subtyping for primitive types. Also Java
    has object oriented equivalents for each of the primitive types
    and automatically converts them back and forth as appropriate.

    To capture this behavior we would like to overload primitive
    types, much in the same way that numeric types are overloaded
    in standard Haskell via the type classes \#Num#, \#Frac#, etc.
    Thus we create a type class for every primitive type and add
    instances for all Haskell types that can be used like such a
    type.
    
    Here is how an exemplary \#JInt# type class could look like,
    which resembles the Java native type \#int#.

.haskell
    class JInt a where
        toInt :: a -> Java Int32 -- java int is a 32 bit signed integer.
.

    It is worth noting that -- in contrast to e.g. \#fromInteger# of
    the \#Num# type class -- the function is not a pure function, but
    a monadic function which executes in the Java monad. This is
    useful since it will allow us to implement *auto boxing*. Auto
    Boxing in Java is a feature that allows a primitive type to be
    automatically converted into an object type. An object however
    has to be allocated on the heap in the virtual machine, which
    is a side effect.

    It will further allow us to transparently convert between Java
    data structures and Haskell data structures such as \#Map<k,v># and
    \#[(k,v)]# or \#java.lang.String# and \#[Char]#.

=== Objects
label sec:javaObjects

    Objects may be represented as \#newtype# declarations which
    hold a reference to the actual object (since that is living
    in the Heap of the virtual machine). In the next sections
    is, among other things, a mechanism introduced for simulating
    subtype polymorphism using type classes which involves the
    creation of a type class for every Java type. Thus every Java
    type introduced several types in Haskell which we will
    distinguish by appending an apostrophe to one of them:

.haskell
    newtype String' = String' ObjectReference
    class String a where ...

=== Subtype Polymorphism
label sec:javaSubtypes

    The subtype polymorphism in Java effectively makes every method
    in Java a polymorphic method. Whenever a parameter of type \#X# is
    declared it may be given every value of a type \#X# or a
    subtype of \#X#. What this means is: The type of the value must
    at least support the same class interface as the type \#X#.

    A suitable translation from Java to Haskell would therefore be:
    For each class interface a type class shall be defined that
    resembles the class interface. Wherever a Java type \#X# is
    mentioned, replace it with a polymorphic type variable that
    is restricted with a context that requires the type of the variable
    to have an instance of the corresponding type class.

    A suitable translation of the signature for the Java method
.java
    String getenv(String)
.
    would therefore be:

.haskell
    getenv :: forall a b (String a, String b) => a -> b
.
    It is worth noting that *a* and *b* are distinct type variables
    here, since it is entirely possible that they do not refer
    to the same type but two different types which both happen to be
    a subtype of String (in this particular example this will not be the
    case since String is declared *final* in the Java standard library).

    There is however a problem with this declaration: When the return type
    of a function call is polymorphic then in Haskell the caller will
    determine the actual type. But in Java the callee will determine
    the type of the returned value, and it will do so at runtime. Thus
    all we know is that we will get a String:

.haskell
    getenv :: forall a. String a => a -> String
.
    A function \#cast :: a -> Maybe b# could be used to check whether
    a value is actually a value of type *b* and return the casted result
    when this is the case or \#Nothing#.

    But there is still a problem with this declaration: Every reference
    in Java maybe the \#null# reference. Thus a proper translation of
    the above method signature to Haskell would be:

.haskell
    getenv :: forall a. String a => a -> Maybe String
.
    Yet this declaration is not perfect. The name \@String@ is used
    as a type class in the context and as an actual type in the return
    type. We fix this by augmenting the type \@String@ with an apostrophe
    (a valid name in Haskell):

.haskell
    getenv :: forall a. String a => a -> Maybe String'
.

    How could the definition for the actual type class \#String# look
    like? For now we will define an empty class \#String#:

.haskell
    class String a
.
    In order to use a type as a String it suffices to declare it an
    instance of the type class \#String#. Here are two such instances:

.haskell
    instance String [Char]
    instance String String'
.
    We will defer the discussion on how the implementation of these
    instances (and the definition of the above type class) should look
    like to the section about the implementation of the java-bridge
    library.

    Invoking the static \@java.lang.System#getEnv(String)@ method in
    Haskell could now look like the following:

.haskell
    main = do
        runJava (getenv "HOME") >>= maybe
            (putStrLn "HOME environment variable not defined")
            (putStrLn . javaStringToHaskellString)
.
    As a matter of fact it might also be possible that \#null#
    should be passed as an argument to an object parameter.
    For this case we make \#Maybe String'# an instance of the class
    \#String#:

.haskell
    instance String (Maybe String')
.
    The following invocations of getEnv will now all be legal:

.haskell
    main = runJava $ do
        str1 <- new'String "a string object in java"
        getEnv "HOME"
        getEnv Nothing
        getEnv str1
        getEnv (Just str1)
.
    In order to properly model the subtyping relationships of
    the \#String# type, we should also create instances for all
    its super types:

.haskell
    instance Object String'
    instance Serializable String'
    instance CharSequence String'
    instance Comparable String'
.
    The inheritance can also be presented in the declaration of
    the \#String# type class:

.haskell
    class (Object a, Serializable a, CharSequence a, Comparable a) => String a
.

=== Static and Non-static Methods
label sec:staticAndNonStaticMethods

    Static methods can be easily translated by creating a
    function in Haskell with the same number of arguments as
    the Java function. Non-static methods are bound to an
    object and need to be augmented with an additional
    \#this# parameter that allows for passing the reference
    to the bound object to the function. An example can be
    seen in figure \<fig:thisParameter>.

figure
.haskell
    toString :: Object -> String
caption The Object.toString() method as a Haskell function.
label fig:thisParameter
endfigure

    Since a method can also be invoked on all subtypes of the
    type it was declared in, we will design that \#this#
    parameter as a polymorphic argument, just like any other
    object parameter, as seen in section \<sec:javaSubtypes>.
    An example of this can be seen in \<fig:polymorphicThis>.

figure
.haskell
    toString :: Object this => this -> String
caption A Java method as polymorphic Haskell function.
label fig:polymorphicThis
endfigure


=== Higher Kinded Types and Type Variables
label sec:javaHigherKinds

    Java does have higher kinded types through *generics*.
    An example for that is the type \#Collection<E>#. Such types
    can be translated into Haskell types very easily, since the
    concept of type variables is roughly the same in both languages.
    Figure \<fig:functionTypeVar> shows a rather contrived example
    for the Java method \#V Map<K,V>.put(K key, V value)#.

figure
.haskell
    put :: (Map (this key value), Object key, Object value)
        => this key value -> key -> value -> Java value
caption Translation of a non-static method  involving type variables.
label fig:functionTypeVar
endfigure

    There is a slight cave-at with this approach though.
    Java does not give up on polymorphism in the presence of
    type variables. Thus it is perfectly valid to invoke
    a java method \#void AType<A>.aMethod(A a, A b)# with two arguments
    that only have \#A# as a common super type, but are not
    actually of the same type.

    A translation of this behavior is possible by making
    the subtyping relationship between two objects explicit.
    Relations between types can be expressed using an extension
    to the Haskell standard known as *multi parameter type classes*
    (\#MultiParamTypeClasses# in both GHC and Hugs). An example
    of this can be seen in \<fig:typeVarWithSubtypingRelation>.

figure
.haskell
    aMethod :: (AType (this a), InstanceOfAType a1 a, InstanceOfAType a2 a)
           => this a -> a1 -> a2 -> void
caption The InstanceOfAType relation realizes subtyping.
label fig:typeVarWithSubtypingRelation
endfigure

    We will however refrain from the use of multi parameter
    type classes, for several reasons. First of all, they are
    not standard Haskell. Second, multi parameter type classes
    are mostly useless regarding type inference and type checking.
    In most situations they require further extensions like
    *functional dependencies* or *associated types* to give
    hints to the type inference engine and the type checker.
    Even with these extensions they will lead to ambiguity
    which in turn will require the programmer to give lots of
    type annotations.

    Nonetheless we want to preserve the calling semantics of
    Java in our translation or at least offer a way to reproduce
    these. This can be achieved by explicitly down casting
    values where necessary. A function to so is discussed in
    Section \<sec:coerce>. Calling a function such as the exemplary
    method \#aMethod# from figure \<fig:typeVarWithSubtypingRelation>
    might than look like in figure \<fig:callFunctionWithCoerce>.

figure
.haskell
    run :: (AType (x a), Object b, Object c) => x a -> b -> c -> Java ()
    run x a1 a2 
            aMethod x (coerce a1) (coerce a2)
caption
label fig:callFunctionWithCoerce
endfigure

    It is worth noting that coerce returns \#Maybe b#. This is perfectly
    well since there exist instances for both \#Object# and \#Maybe Object#,
    where \#Nothing# denotes the \#null# reference. Also, since the lower
    bound is articulated in the context of \#run#, we can be sure that only
    a \#Just Object# can and will be returned.


:=  Constraints on type variables:
    The previous example leads directly to another feature of type variables
    in Java. Since type variables themselves denote existential types we need
    a way to express this in Haskell. In Java, a lower or an upper bound on a
    type variable can be specified using the keywords \#extends# and \#super#
    in the declaration of a type variable. Such a thing (escpecially an upper
    bound induced by \#super#) is difficult, if not impossible, to translate
    in standard Haskell. Here again an explicit translation would involve
    *multi parameter type classes* that make the subtype or supertype
    relationship explicit. Without resorting to multi parameter type classes
    we will simply drop those constraints and resort to \#coerce# where
    necessary.

    This is by all means a pragmatic decision. Multi parameter type classes
    would be an excellent tool for expressing the subtyping relationship,
    but they induce several problems by themselves. Furthermore we would
    gain very little: \#extends# and \#super# are a means to introduce
    subtyping to the otherwise invariant type variables, something which
    a Haskell programmer is not used to anyway. Furthermore only very little
    code actually uses bounded type variables (they are not only complicated
    in Haskell but also in Java). Making type variables always invariant
    and requiring explicit coercion where needed seems to be the right
    thing to do$\texttrademark$, with regard to the usability of the
    resulting translation.


=== Arrays
label sec:arrays

    Arrays in Java are a special datatype with special support
    in the syntax of the Java programming language as well as in
    the instruction set of the Java virtual machine. While in
    principle arrays are plain collections with a type of kind
    \#* -> *#, they have special (and unsafe) semantics regarding
    subtyping:

figure
.java
    Number[] arr = new Integer[] { 1 };
    arr[0] = 2.0;
.
caption This results in an ArrayStoreException.
label fig:arrayStoreException
endfigure
    
    This does not happen with generic types, since -- in contrast
    to arrays -- they are *invariant* in the type of the elements
    and therefore two arrays with differing element types can not
    possibly be subtypes of each other.

    The reason for why arrays work differently than generics is
    that they existed long before generics were introduced. As we
    do not want to reproduce this possible source of defects,
    we simply treat Arrays as an ordinary object type of kind
    \#* -> *#, as if they were a type \#Array<E>#.

    On a side note: This would be impossible to do in Java since
    type variables can not be replaced by primitive types, i.e.
    there can not be a type \#Array<int>#. In Haskell there is no
    such restriction (technically every type in Haskell is boxed
    and unboxing is an optimization performed by the compiler,
    thus the annoying difference of boxed vs. unboxed types does
    not leak into the type system).

    Here is an exemplary signature for a Java method that takes
    an array of \#int# (\#int[]#) and returns nothing (\#void#):

.haskell
    arrayMethod :: JInt a => Array a -> Java ()
.

:=  Setting fields:
    While the type of an array itself should be invariant (which
    is ensured by the above definition), it should still possible to
    add values of a subtype of the element type to an array. This
    is ensured due to the modelling of Java subtyping using Haskell
    type classes, as discussed in the previous sections.
    Since arrays are treaded as just another datatype, the same
    properties apply to the translation of array methods as to
    the translation of generic types in general.

    Two special functions are necessary however: Since Java offers
    a special syntax for accessing arrays we need a \#get# and a
    \#set# method for arrays. As usual we resort to fighting our
    battle using type classes:

figure
.haskell
    class JavaArray array where
        get :: array e -> Int32 -> Java e
        set :: array e -> Int32 -> e -> Java ()

    instance JavaArray (Array e) where
        -- implementation is discussed in a later section
caption A typeclass for Java arrays.
endfigure

    

figure
.haskell
    objectArrayMethod :: String s => Array (Array s) -> Java ()
.
caption A method void objectArrayMethod(java.lang.String[][]).
endfigure


=== Method Return Types and Exceptions
label sec:returnTypesAndExceptions

    Checked exceptions are one on the most controversial features
    of Java. In fact, exceptions in general are a highly discussed
    topic. The go programming language for example ditched them
    altogether in favor of multiple return types. In Haskell exceptions
    exist, but only within monads. Besides that different styles of
    exception handling are being used and advocated.

    Since every interaction with the virtual machine happens within
    the Java monad we can always resort to \#fail#, which will terminate
    the currently running program and raise an exception in the IO monad.

    An alternative way of handling exceptions is to return a value of
    type \#Either e a#, where \#e# is the type of the exception and \#a#
    is the type of the expected non-exceptional value. In Java there is
    also the possibility of \#null# being returned from any method
    that returns an object (which can be considered an exception too).
    That would be best reflected as the type \#Maybe a# in Haskell.

    An adequate translation which combines these features would
    therefore be:
.haskell
    currentThread :: Either Exception (Maybe Thread)
.
    There is a hidden agenda in the selection of the above example.
    While it certainly is an adequate translation it is also a very
    unpleasant one. Although \#currentThread# will never return
    \#null# the user is forced to consider this case. Also \#currentThread#
    will never throw an exception, but again the user is forced to
    consider this case:

.haskell
    runJava $ do
        (Right (Just thread)) <- currentThread
        ...
.
    Luckily the return type of a function can be polymorphic
    in Haskell *and* it is determined by the caller, not the callee.
    We will use this flexibility and offer different implementations
    using type classes and overloading:

.haskell
    class ObjectResult m where
        toObjectResult :: Either JThrowable (Maybe JObject) -> Java m

    instance ObjectResult (Maybe a) where
        -- implementation details are discussed later on

    instance ObjectResult (Either JThrowable a) where
        ...
.
    The signature for \#currentThread# now looks like:
.haskell
    currentThread :: ObjectResult object => object Thread
.
    The following usages are now all legal:
.haskell
    runJava $ do
        (Just thread) <- currentThread
        currentThread >>= \result -> case result of
            (Left exc) -> {- handle exception -}
            (Right value) -> {- handle value -}
.
    It is worth noting that in standard Haskell it is not possible
    to simultaneously define \#instance ObjectResult a# (for accessing
    the return type directly) and \#instance ObjectResult (Maybe a)#
    since these instances overlap (\#a# subsumes \#Maybe a#). It is
    nevertheless possible to define such instances using the
    \#OverlappingInstances# extension.

    It would also be possible to create a type class for
    every actual return type, such as \#class StringResult#
    or \#class ThreadResult#, which would than allow for a
    usage like this:
.haskell
    runJava $ do
        t <- currentThread :: Java Thread
        t <- currentThread :: Java (Maybe Thread)
        t <- currentThread :: Java (Either (Maybe Thread))
.


=== A Note on Return Types and Type Casts
label sec:coerce

    The return type of a Java method is actually an existential
    type, which is not supported by standard Haskell. Therefore
    return types are not translated in the same way as method
    parameters, i.e. not polymorphic. Whether a value actually
    does have a specific type needs to be checked at runtime.

    A safe function for checking this and if necessary coercing
    the value would have a signature like this:
.haskell
    coerce :: a -> Maybe b
.

    In principle such a function could only ever return \#Nothing#,
    since otherwise it would know how to create a \#String# from
    an \#Int#, as well as a \#FlyingCarpet# from a \#BufferedStringBuilder#.
    It surely needs some more information to fulfil its duty.
    We know two things: \#coerce# performs a cast on Java objects,
    and it asks the virtual machine for whether it can perform a
    certain cast or not. Thus we create a type class for Java Objects
    which can, for each type, query the virtual machine for whether
    a given object can be cast to its object type or not:

.haskell
    class JavaObject b where
        coerce :: JavaObject a => a -> Java (Maybe b)
.
    Every Java type needs to have an instance of \#JavaObject# for
    this to work.
    

=== Anonymous Classes
label sec:callbacks

    To enable a Haskell programmer to completely make use of a
    Java library it is crucial that dynamic instances of Java
    interfaces can be created. This is necessary for example
    to provide callbacks, for example for event handlers in
    Swing or for spawning a thread in Java (using the
    interface \#java.lang.Runnable#).

    Up until now we only translated functions so that we could
    call them from Haskell, action would take place in a virtual
    machine instance. This time we want to create a data object
    in Haskell which can be exposed to the virtual machine and
    act like a Java object.

    We will not discuss the technical details in this place
    (we will do so in a later section dealing with the actual
    implementation of the java-bridge library), but outline the approach.

    The simplest case are interfaces which specify exactly one
    method. A Haskell function itself can be regarded as an
    instance of such an interface.

    Interfaces which specify more than one method need to be
    modeled as a more complex datatype than one ordinary function.
    Thus an algebraic datatype for an should be created for
    interfaces with more than one public method. The names for the
    method functions are chosen according to the same rules as
    otherwise.

figure
.haskell
    myThread :: Java ()
    myThread = do
        Thread.sleep (500 :: Int)
        return ()
caption A perfectly valid Haskell representation of an object that implements java.lang.Runnable.
endfigure

figure
.haskell
    data Iterable e = Iterable {
        hasNext :: Java Bool,
        next :: Java (Maybe e),
        remove :: Java ()
     }
caption Representation of a more complex interface: java.lang.Iterable
endfigure

figure
.haskell
    myIterable :: Iterable Int64
    myIterable = Iterable {
        hasNext = do
            return False,
        next = do
            return Nothing,
        remove = return ()
     }
caption An implementation of the empty iterator.
endfigure
    
    In order to use these declarations as Java objects,
    they need to be made an instance of the correspondent
    type classes. For arbitrary functions this will require
    the *flexible instances* language Extension of Haskell.
    If we want to circumvent this, the function has to be
    wrapped in a \#newtype#:

    Example with FlexibleInstances:
.haskell
    instance Runnable (Java ()) where
        ... -- implementation is discussed later on
.
    Using a \#newtype#:
.haskell
    newtype RunnableFunc = RunnableFunc (Java ())
    instance Runnable RunnableFunc where
        ...
.
    It is now possible to use such a definition transparently
    to create anonymous class instances:

.haskell
    (Just t) <- new'Thread (RunnableFunc (sleep (500 :: Int32) >> return ()))
    start t
.

    \#FlexibleInstances# make it just slightly more convenient to
    use:

.haskell
    (Just t) <- new'Thread (sleep (500 :: Int32) >> return ())
    start t
.
    Up until now we only translated Java methods to Haskell functions
    so that we could call them from within Haskell. In this setting
    however, the virtual machine is going to
    call back into Haskell and code written in Haskell is going
    to be executed. Because of this function signatures will look
    different, i.e. the function arguments need not be polymorphic.
    This is due to the fact that inside of the function we will
    need to access the arguments and we have no clue there what
    exact type the virtual machine will have given us. For all
    we know we get types as specified in the signature of a method
    (this is the same in Java). Accessing arguments as concrete
    subtypes requires converting them using \#coerce#, just as you
    need to check a value using \#instanceof# in Java and doing an
    explicit cast.

figure
.java
    public interface Example<E> {
        List<E> getSequence(int howMuch);
        int count(Collection<E> coll);
    }
.haskell
    data Example e = Example {
        getData :: Int32 -> Java (List e),
        count :: Collection e -> Java Int32
     }
caption An example interface and its record which can be used as a callback.
endfigure
    

=== Summary

    Up until now we have discussed a scheme for translating Java idioms
    into Haskell equivalents in order to invoke methods in a virtual
    machine. We left out so far the actual implementation of this.
    It will be discussed in section \<sec:library> and \<sec:j2hs>
    in which a general library for accessing a virtual machine via
    the JNI is built and a tool for the automatic generation of
    bindings to the Java standard library presented (a tool which
    automatically creates the translation discussed above).

    The translation scheme proposed so far compromises the following
    rules:

*   **Fields**, **methods**, and **constructors** are translated into functions.
    The naming rules from section \<sec:names> make sure that the names
    do not clash with each other and do not accidentally result in a
    reserved name of the Haskell programming language.

*   Since every action happens inside the Java virtual machine,
    every translated function is bonded to a special monad, the
    **Java monad**. The Java monad is a monad transformer on top of the
    IO monad, since it is strictly more powerful than the IO monad
    (in addition to IO actions in can perform Java action).
    This was discussed in section \<sec:javaMonad>.

*   Type classes are to be created for the **primitive types** in order
    to allow automatic conversion between Haskell values and Java
    values. Furthermore this approach allows for auto-boxing conventions
    to be implemented just like in the Java programming language
    (i.e. a method that takes the primitive type \#int# as its first
    argument can equally well be invoked with an object of type
    \#java.lang.Integer#). The standard representation of primitive
    types are the basic types from Haskell2010 (Int32, Char, etc.).
    This was discussed in section \<sec:primitiveTypes>.
    \break
    It is worth noting that it may seem rather irritating that the
    type classes being defined do not contain any functions at all.
    It would be completely possible to add the non-static methods
    of an interface or a class to the type class definition.
    This does however not include the non-static interfaces.
    Furthermore we will see later on that we run into trouble
    implementing such type classes due to mutually recursive definitions.
    The sole purpose of type classes and instances is therefore
    to model the inheritance hierarchy.

*   **Subtyping** is simulated using Haskells type classes. For each
    Java type, a Haskell type class is to be created. A concrete object
    type is made an instance of all type classes that resemble supertypes
    or interfaces implemented by that type. This was discussed in
    section \<sec:javaSubtypes>.

*   **Generic types** are more-or-less translated as is, since type variables
    are a common feature of Java and Haskell. Upper and lower bounds on
    type variables are discarded in order to reduce the complexity of
    the resulting translation. To compensate for this a coercion function
    \#coerce# has to used which is defined in a type class \#JavaObject#
    of which every object type is a member. This was discussed in section
    \<sec:javaHigherKinds>.

*   While **arrays** are a specialized datatype in its own right in the
    Java programming language, they are treated as an ordinary generic
    type, parameterized in its component type. This was discussed in
    section \<sec:arrays>.

*   Polymorphic return types are exploited to let the programmer decide how
    to handle **exceptions**. For each type a type class \#<Type>Result#
    is created (in case of objects the clutter can be reduced to a
    single \#ObjectResult# class). If an exception is discarded by
    the programmer, an exception is raised using the native monadic
    \#fail# function. This mechanism will also allow convenient
    marshalling between Haskell values and Java objects.
    This was discussed in section \<sec:returnTypesAndExceptions>.

*   **Callbacks** that allow the virtual machine to call back into the
    enclosing Haskell program are created by declaring functions or
    records as an instance of the corresponding type class that resembles
    the interface to be implemented by these functions.
    This was discussed in section \<sec:callbacks>.

*   Sometimes it is necessary to perform **casts** between types.
    This situation arises in both Java as in Haskell. A type safe
    \#coerce# function is proposed which checks whether a cast is
    possible and performs it if that is so.

figure
.haskell
    newtype Object' = Object' ObjectReference
    class Object a
    instance Object Object'

    toString :: (Object this, ObjectResult (object String'))
        => this -> object
    equals :: (Object this, Object a1, BooleanResult boolean)
        => this -> a1 -> boolean
    -- ... further object functions ...

    newtype String' = String' ObjectReference
    class (Object a) => String a
    instance Object String'
    instance String String'
    -- ... string method functions ...

    newtype Map' k v = Map' ObjectReference
    class Map' a
    instance Map (Map' k v)

    entrySet :: (Map (this k v), ObjectResult (object (Set' (MapEntry' k v))))
        => this k v -> object (Set' (MapEntry' k v))
    -- ... further map method functions ...
caption A (shortened) exemplary translation of certain Java types.
endfigure

newpage
==  Translating Haskell idioms into Java

    The public API of a Haskell package consists of a set of *modules*.
    A module declares a public interface, that is a set of public
    functions and types.

    Translating such an interface into Java requires finding a
    suitable representation of Haskell idioms in the Java language.

=== There is only Data

    In Haskell there is only data which may be of a certain type.
    That type in turn has a certain kind, like \#*#, or \#* -> * -> *#.
    The kind of a type simply specifies how many arguments a type
    constructor takes. We translate that into Java by creating
    a Java type for each Haskell type and adding as many type variables
    as necessary to capture the kind of that type.

    Certain datatypes -- functions, lists, and tuples lists --
    have a special syntax in Haskell (\#->#, \#[]#, \#(,,)#).
    They will be translated using default names like \#Function#,
    \#List#, or \#Tuple3#.

    Here are some example translations:

>!  Haskell
>!  Java
>-
>#  Map k v
>#  Map<k,v>
>+  
>#  Int32
>#  Int32
>+
>#  Either (Maybe a) [String]
>#  Either<Maybe<a>,List<String>>
>+
>#  (a, b, c)
>#  Tuple3<a,b,c>
>+
>#  a -> (Int,[b])
>#  Function<a,Pair<Int,List<b>>>
>+
>#  a -> a -> a
>#  Function<a,Function<a,a>>

    There is a slight deficiency of this translation scheme:
    Java does *not* support higher kinded type variables,
    i.e. a function like \#(a -> b) -> f a -> f b# can not be
    translated as \#Function<Function<a,b>,Function<f<a>,f<b>>>#,
    since \#f# is a type variable and can not be parameterized.

    This can be partially remedied, see section
    \<sec:typeClassesAsInterfaces> for that.

%   (On a side note: If one looks in the Java reflection classes
    for type variables and parameterized types one can see that
    the creator of the Java Reflection API anticipated the
    possible addition of higher kinded type variables, since the
    API actually does support the notion of parameterized type
    variables. ).
    

=== Algebraic Datatypes and Constructors

    Algebraic datatypes are the bread and butter of Haskell. They are
    constructed using constructors. A constructor in Haskell is similar
    to a constructor in Java, yet completely different. A constructor
    in Java is associated with the initialization of the state of an
    object, whereas a constructor in Haskell is simply a function that
    creates objects (and since there is no state in Haskell, no initialization
    is done).

figure

.haskell
    data ParseResult a = Error  { line: Int, message: [Char] }
                       | Result { info: Info, tokens: a }
.
caption An algebraic datatype in Haskell.
label fig:parseResult
endfigure

    Algebraic datatypes are also known as *discriminated unions* or
    *tagged unions*. This basically means that one type can store
    different types and it knows which type it actually stores.

    Figure \<fig:parseResultC> shows how such a tagged union could
    look like in the C programming language.
    
figure
.code
    enum parse_result_e { ERROR, RESULT }
    union ParseResult {
        enum parse_result_e type;
        struct {
            line_t line;
            char* message;
        };
        struct {
            into_t info;
            result_t tokens;
        };
    }
.
caption A tagged union in C.
label fig:parseResultC
endfigure

    While this declares how the data is represented in memory (something
    we do not have to worry about using Haskell), this is not everything
    that is being declared in figure \<fig:parseResult>. In fact, there
    are actually **seven** things being declared here:

+   A type constructor \#ParseResult :: * -> *#
+   A constructor function \#Error :: Int -> [Char] -> ParseResult a#
+   A constructor function \#Result :: Info -> [a] -> ParseResult a#
+   An accessor function \#line :: ParseResult a -> Int#
+   An accessor function \#message :: ParseResult a -> [Char]#
+   An accessor function \#info :: ParseResult a -> Info#
+   An accessor function \#tokens :: ParseResult a -> [a]#

    For a complete translation to Java each of these things has to
    be translated:

+   The type itself can be translated into an abstract
    class with a private constructor. The constructor has to be private
    in order to prevent creation of subclasses outside of the
    definition, since algebraic datatypes can not be extended
    after their declaration.
+   Each constructor yields an enclosed class and a static
    factory function. The constructors of the enclosed classes
    again are private, in order to prevent instantiation of these
    classes in other ways than by the factory functions.
    By declaring classes for every constructor, simple pattern matching
    can be simulated by means of the \#instanceof# operator
    in Haskell.
+   For each field that a record can hold, a private final field
    is generated in the corresponding member class. A public
    getter is defined for each field in both the abstract class
    (marked as abstract) as in the member class representing
    the corresponding Haskell constructor.
+   The getter functions throw an error if invoked on a
    member class which actually does not have the
    corresponding field (this is the same behavior as
    in Haskell).
    

    The algebraic datatype \#Maybe# can now be translated as can
    be seen in figure \<sec:maybeJava>.

figure
.haskell
    data Maybe a = Nothing | Just a

#java Maybe.java
caption Translation of the algebraic datatype Maybe to Java.
label fig:maybeJava
endfigure
    
=== Type Classes
label sec:typeClassesAsInterfaces

    Type classes can be understood as interfaces. A Haskell type
    can be part of multiple type classes, and so a Java type can
    implement multiple interfaces. Furthermore there is a problem
    with higher kinded type variables -- there are non in Java.
    It turns out however, that higher kinded type variables
    almost never make any sense if not constrained by a certain
    context, i.e. such type variables are always part of a
    certain type class (or multiple type classes).

    The monadic return function \#a -> m a# for example can not
    return any type at all without knowing how to create \#m# values.
    It is hence part of the type class \#Monad# which provides
    this information (if there is an instance for the desired type).

    If type classes are translated using Java interfaces our
    problem with higher kinded type variables goes away.

    Consider the type class Functor:

.haskell
    class Functor f where
        fmap :: (a -> b) -> f a -> f b
.
    It can be translated to the following Java interface:

.java
    public interface Functor<A> {
        public Function<Functor<A>,Functor<B>> fmap(Functor<Function<A,B>> f);
    }
.
    This definition however needs to be relaxed a bit. Since parameterized
    types are invariant in their type parameters in Java we can not create
    an appropriate implementation of Functor for e.g. a \#List<A># class.
    The type parameters need to be made covariant, i.e. allow for a
    subtype in order to properly implement \#fmap#.

figure
.java
    public interface Functor<A> {
        public <B> Function<? extends Functor<A>,? extends Functor<B>>
            fmap(Function<A,B> f);
    }


    public class List<A> implements Functor<A> {
        public <B> Function<List<A>, List<B>> fmap(final Function<A,B> f) {
            return ...
        }

        /* remaining methods */
    }
caption The Haskell type class "Functor" as an interface in Java.
label fig:functorJava
endfigure

    Figure \<fig:functorJava> shows a proper example of the \#Functor# interface, including an
    (incomplete) implementation of a fictitious \#List# class (it concentrates
    on the types only here):

    This way we not only have resolved the issue with higher kinded type
    variables, but also we eliminated the context \#Functor f =># by moving
    it into the signature.

    There is a cave-at though. Consider the following, admittedly rather complex,
    function signature taken from the Parsec parser combinator library:

.haskell
    runParsecT :: Monad m => ParsecT s u m a -> State s u -> m (Consumed (m (Reply s u a)))
.
    The problem in this definition is that this time "m" can not be
    replaced like in the previous example. In fact, there really is no
    higher kinded type variable in the definition of \#fmap#. The type
    \#f a# has the ordinary kind \#*#, which is why we could replace it
    with a Java type of the same kind (\#Functor<A>#). But \#m# in the
    signature of \#runParsecT# really *has* the higher kind \#* -> *#.

    Furthermore: If we replaced \#m# in the signature of \#runParsecT#
    where it is actually applied to a type argument, we would lose the
    ability to express that the first \#m# in the return type is exactly
    the same type as the second m (again of kind \#* -> *#).

    Bacause of this shortcoming in Java generics certain (admittedly
    contrived) types can not be properly resembled in Java. Most
    prominently it is not possible to properly express monad transformers
    (they always take a type constructor somewhere, and in fact,
    \#runParsecT# was not chosen without second thoughts, since
    \#ParsecT# is in fact a monad transformer that wraps any given
    monad \#m#).


=== Polymorphic Return Types

    Except for type constructors and higher kinded type variables,
    the translation of a Haskell interface into Java seems to be
    rather straight forward till now. There is however one further
    corner case which does not have a translation as obvious
    as the exemplary types from the beginning of this section:
    Polymorphic return types. Consider the following two examples:

.haskell
    id :: a -> a
    minBound :: Enum e => e
.
    Translating \#id# indeed *is* straight forward:
.java
    public static <A> A id(A a);
.
    \#minBound# howevers poses a problem:
.java
    public static <E> E minBound();
.
    What exactly should \#E# be? In Java it is not possible
    to select the type like in Haskell via \#minBound :: Int#.
    There are only three things that can be returned here:
    (1) a value of type Object, (2) the null reference,
    (3) throw an exception.

    This is very similar to a Haskell function \#f :: Maybe e#.
    This function can only return (1) \#Nothing#, (2) or \bot 
    (In the Java case the additional third value of type \#Object#
    is in the set of possible return values since generic types are
    always at least an object, however a plain Object is just about
    as meaningless as the null reference).

    But: We missed something! In contrast to \#f#, \#minBound#
    provides some additional info: \#e# should be a member of the
    type class \#Enum#. Lets reconsider our translation to
    Java and include that extra information:

.java
    public static <E> E minBound(Class<E>);
.
    The java compiler can now deduce that the return type of
    \#minBound# must be the same type as the type parameter
    to \#Class#. Also it is now possible to pick a value
    for the return type, though it has to be done at runtime,
    whereas the selection of an appropriate instance can be
    done at compile time in Haskell.

=== Summary

    While a possible translation of Haskell to Java seems feasible,
    even easy, at first, it turns out it is not. Although the core
    of Haskell is a very simple language (we have seen that everything
    is data of a certain type, types have certain kinds, and that's
    pretty much it), the devil is in the details. Expressing type
    constructors and higher kinded type variables in
    Java is simply not possible (or at least not in all cases).

    We have not yet looked at

*   how to translate names from Haskell to Java;
*   how to deal with the different execution models of Haskell and Java;
*   how to deal with exceptions.

    Since both Haskell and Java do have exception, we could
    simply raise a \#HaskellException# if anything goes wrong when
    invoking a Haskell function.

    The different execution models are a bit tougher:
    While in principle very similar, there are corner cases
    which may go wrong. As we have seen, Haskell can have
    infinite lists and make something useful out of a
    computation that would not return in a strict execution
    model. Care must be taken when translating such a function,
    e.g. by translating it not as a list but as an \#Iterable#.
    The most important thing to keep in mind is that the
    invocation should not force the value to be evaluated as
    this would be exactly what could result in an infinite loop.
    Instead we have to reproduce the semantics by implementing
    explicit laziness.

    The most difficult part is the translation of names from Haskell
    to Java. Haskell allows the programmer to define arbitrary
    operators, and the authors of many Haskell libraries do use
    this feature exhaustively. In order to translate such functions
    we would have to come up with a translation scheme that in any
    case will look ugly to the eye of both the trained Haskell
    as well the fine Java programmer.
    
    
